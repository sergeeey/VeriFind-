"""Portfolio optimization API routes."""

from datetime import datetime
from typing import Any, Dict, List, Literal, Optional
import logging

import pandas as pd
import yfinance as yf
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field, field_validator

from ...portfolio.optimizer import (
    OptimizationConstraints,
    PortfolioOptimizer,
    compute_efficient_frontier,
)

router = APIRouter(prefix="/api/portfolio", tags=["Portfolio"])
logger = logging.getLogger(__name__)


class PortfolioOptimizeRequest(BaseModel):
    """Request schema for portfolio optimization."""

    tickers: List[str] = Field(..., min_length=1, max_length=20)
    start_date: str
    end_date: str
    objective: Literal["max_sharpe", "min_volatility"] = "max_sharpe"
    risk_free_rate: float = Field(default=0.04, ge=0.0, le=0.2)
    min_weight: float = Field(default=0.0, ge=0.0, le=1.0)
    max_weight: float = Field(default=1.0, ge=0.0, le=1.0)
    frontier_points: int = Field(default=20, ge=5, le=200)

    @field_validator("tickers")
    @classmethod
    def normalize_tickers(cls, values: List[str]) -> List[str]:
        normalized = [ticker.strip().upper() for ticker in values if ticker.strip()]
        if len(set(normalized)) != len(normalized):
            raise ValueError("Tickers must be unique")
        if not normalized:
            raise ValueError("At least one ticker is required")
        return normalized


def _download_returns(tickers: List[str], start_date: str, end_date: str) -> pd.DataFrame:
    """Download market data and compute daily returns."""
    data = yf.download(
        tickers=tickers,
        start=start_date,
        end=end_date,
        auto_adjust=True,
        progress=False,
    )

    if data is None or data.empty:
        raise ValueError("No market data returned for requested tickers/date range")

    # yfinance returns MultiIndex columns for multi-ticker queries
    if isinstance(data.columns, pd.MultiIndex):
        if "Close" in data.columns.get_level_values(0):
            close = data["Close"]
        else:
            close = data.xs("Close", axis=1, level=0, drop_level=False)
            close.columns = [col[-1] for col in close.columns]
    else:
        # Single ticker fallback
        if "Close" not in data.columns:
            raise ValueError("Downloaded data does not contain Close prices")
        close = data[["Close"]].rename(columns={"Close": tickers[0]})

    returns = close.pct_change().dropna()
    if returns.empty:
        raise ValueError("Insufficient return history for optimization")
    return returns


@router.post("/optimize", response_model=Dict[str, Any], status_code=status.HTTP_200_OK)
async def optimize_portfolio(request: PortfolioOptimizeRequest):
    """
    Optimize portfolio weights using deterministic MPT execution.

    Critical: Weights are derived from numerical optimization code execution,
    not generated by LLM output.
    """
    try:
        returns = _download_returns(
            tickers=request.tickers,
            start_date=request.start_date,
            end_date=request.end_date,
        )

        constraints = OptimizationConstraints(
            min_weight=request.min_weight,
            max_weight=request.max_weight,
            sum_weights=1.0,
        )

        optimizer = PortfolioOptimizer(returns=returns)
        if request.objective == "max_sharpe":
            portfolio = optimizer.max_sharpe_ratio(
                rf_rate=request.risk_free_rate,
                constraints=constraints,
            )
        else:
            portfolio = optimizer.min_volatility(constraints=constraints)

        frontier = compute_efficient_frontier(
            returns=returns,
            n_points=request.frontier_points,
            rf_rate=request.risk_free_rate,
            constraints=constraints,
        )

        weights = {ticker: round(weight, 6) for ticker, weight in portfolio.weights.items()}
        frontier_payload = [
            {
                "expected_return": round(point.expected_return, 6),
                "volatility": round(point.volatility, 6),
                "sharpe_ratio": round(point.sharpe_ratio, 6),
            }
            for point in frontier
        ]

        return {
            "timestamp": datetime.utcnow().isoformat(),
            "objective": request.objective,
            "verified_fact": {
                "statement": "Portfolio weights were computed via deterministic MPT optimization execution.",
                "source": "portfolio_optimizer_execution",
                "confidence_score": 1.0,
                "extracted_values": {
                    "expected_return": round(portfolio.expected_return, 6),
                    "volatility": round(portfolio.volatility, 6),
                    "sharpe_ratio": round(portfolio.sharpe_ratio, 6),
                },
            },
            "portfolio": {
                "weights": weights,
                "expected_return": round(portfolio.expected_return, 6),
                "volatility": round(portfolio.volatility, 6),
                "sharpe_ratio": round(portfolio.sharpe_ratio, 6),
            },
            "efficient_frontier": frontier_payload,
            "debate": {
                "note": "Debate layer not enabled for portfolio endpoint yet; weights come from execution.",
                "enabled": False,
            },
        }
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        logger.error(f"Portfolio optimization failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Portfolio optimization failed",
        )
